---
title: HTTP
date: 2020-11-19 16:45:57
tags: 前端优化
categories: 浏览器
---
# **HTTP**


问题：当用户地址栏中输入网址，到最后看见网页，中间经历了什么

## 1、URL地址解析

##### 1、URI、URL、URN

URI（identifier / 统一资源标识符）

​          URL URN（被URI包含）

URL（Locator / 统一资源定位符）

URN（Name / 统一资源名称）

##### 2、解析输入的URL地址

###### **1、传输协议**（把信息在服务器端和客户端传递）

 HTTP：超文本传输协议

HTTPS：比HTTP传输协议更加安全的传输协议（传输通道设置加密算法SSL）

FTP：资源上传协议  一般用于把本地文件直接上传服务器



###### *2、域名**

一级域名 ：www.twilight-down.cn

二级域名：video.twilight-down.cn

三级域名：xx.xx.twilight-down.cn

常用域名性质： .com国际   .cn中国     .gov政府      .org 官方    .net系统     .io博客



###### **3、端口号**（根据端口号，找到当前服务器上指定的服务）

0-65535之间

不同协议默认端口号

HTTP：80

HTTPS：443

FTP：23

###### */4、请求的资源路径和名称**

/vue/index.html



###### 5、伪URL

​	SEO优化

​		静态地址：xxxx

​		动态页面地址：真实地址（URL伪重写技术）

​	数据请求的接口地址

​		/user/list

###### 6、问号传参？xxx=xxx

GET 请求基于问号传参的方式

页面跳转通信

关于传递的信息 需要编码处理（处理特殊字符和中文）

前两中 客户端和服务器端都支持这两种编码解码方式

​	encodeURI decodeURI   //只能把空格和中文汉字进行编码和解码 一般应用这种模式处理整个URL编码



​	encodeURIComponent  decodeURIComponent   //会把所有的特殊字符和汉字都编码，一般不会把整个URL																							 都编码，只会给传递的每个参数值单独编码（模板字符串																																												加${}）

```js
let  str =`http://www.teilight-down.cn?lx=0&url=${encodeURIComponent(xxxxxx)}&name=${encodeURIComponent('某某某')`
console.log(str)
```



​	escape  unescape（不一定所有的后台都有 一般只用于客户端自己内部编码 例如：存储cookie信息）

​	特殊符号也会被编码



###### 7、设置哈希





#### 2、DNS域名解析

发布站点时配置域名解析

网站访问进行DNS域名反解析

DNS Prefetch即DNS预获取

减少DNS请求次数

进行DNS预获取



#### 3、建立TCP连接（三次握手）

第一次握手：由浏览器发起，告知服务器要发送请求

第二次握手：由服务器发起，告知浏览器已经准备接受请求

第三次握手：由浏览器发送，告诉服务器，即将发送请求



#### 4、发送HTTP请求

HTTP请求报文

​	起始行

​	请求头

​	请求主体

强缓存和协商缓存

​	强缓存（Cache-Control 和 EXpire）

​	协商缓存（Last-Modify 和 Etag）

#### 5、服务器得到并处理请求

WEB（图片）服务器和数据服务器

​	Tomcat

​	Apache

​	Nginx

​	IIS

HTTP响应报文

响应状态码

200/201/204

301/302/304/307

400/401/404

500/503

响应头

响应主体



#### 6、断开连接（四次挥手）

第一次挥手：浏览器发起，发送给服务器，请求报文发送完毕，你准备关闭

第二次挥手：服务器发起，发送给浏览器，报文接受完毕 我准备关闭 你也准备关闭

第三次挥手：服务器发起，告知浏览器，响应报文发送完毕 你准备关闭

第四次挥手：浏览器发起，告诉服务器，响应报文接受完毕，我准备关闭，你也准备



#### 7、客户端渲染界面





## **2、性能优化**

#### 1、减少HTTP请求次数和请求大小

+ 文件合并压缩
+ 雪碧图 css sprite
+ 图片base64
+ 尽量使用字体图标
+ 图片懒加载
+ 音视频取消预加载
+ 客户端服务器端信息交互时，使用JSON格式传输（处理数据方便，资源偏小）
+ 开启服务器端的gzip压缩



静态获取的图片

如果css/js文件比较小 用内嵌式可以减少请求（如果css/js文件较大就不行了）

base64：css-js将图片换为一堆代码 不需要发送请求 代码就是图片（代码过多 不方便开发和维护）

​				（webpack的相关加载器 -file-loader可以自动base64）

字体图标 减少HTTP请求次数

动态获取的图片

图片懒加载（数据采取异步分批加载，开始只加载第一屏 看到哪加载哪）

骨架屏技术（首屏内容由服务器渲染 / 开始展示占位结构客户端单独加载）





#### 2、建立缓存机制



把一些请求回来的信息 进行本地存储（缓存存储）

在缓存有效期内再次请求资源从缓存中获取数据，而不是在服务器上

DNS预获取

资源文件的强缓存和协商缓存（304）







####       3、代码上的优化

减少DOM回流 重绘

在js中减少闭包的使用（内存优化）

js避免嵌套循环和死循环

尽可能使用事件委托

减少CSS表达式的使用

css解析规则是从右向左解析 （基于less sass开发尽可能减少层级嵌套，让选择器的前缀更短一点）

a {}  和  .box a{}

实现JS的封装（低耦合高内聚），减少页面冗余代码

css导入事减少@import的使用

能用CSS3不用js

减少递归使用 避免死递归 避免由于递归造成的栈内存嵌套

基于script调取JS时可以使用defer 和async 来异步加载