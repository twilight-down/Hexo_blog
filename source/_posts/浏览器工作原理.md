---
title: 浏览器工作原理
date: 2020-12-06 20:51:58
tags: 浏览器
categories: 浏览器
---

# 浏览器

##### 1、并行处理

计算机中的并行处理就是同一时刻处理多个任务

##### 2、线程，进程

线程不能单独存在，他是由进程来启动和管理的

一个进程就是一个程序执行的实例

##### 3、为什么仅仅打开一个页面却会有四个进程

> **浏览器进程**:负责界面显示，用户交互，子进程管理，同时提供存储功能
>
> **渲染进程：**核心任务是将HTML、CSS、和JS转换为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是在这里运行的，渲染进程都是在沙箱模式下运行的
>
> **GPU进程：**谷歌的UI和CSS3效果都是由GPU绘制的
>
> **网络进程：**负责页面的网络资源加载
>
> **插件进程：**负责插件的运行（插件容易崩溃，防止对浏览器和页面影响）

##### 4、IP、UDP、TCP

1、**IP**是非常底层的协议，只负责把数据包传送到对方的电脑，但是对方电脑并不知道应该将数据包发送给哪个程序

2、**UDP** 用户数据包协议（ User Datagram Protocol ）**IP通过IP地址信息将数据发送给指定的电脑，而UDP通过端口号把数据分发给正确的程序**，但是UDP不能保证数据的可靠性但是传输速度很快 他会将大的文件拆分成小的包去传输（可以应用于直播这种）

3、**TCP：**整的把数据送达应用程序（传输控制协议 面向连接的，可靠的，基于字节流的传输层通信协议）

+ 对于数据包丢失的情况，TCP会提供重传机制
+ 数据包排序机制，保证把乱序的数据包组合成一个完整的文件



> **建立连接**，**传输数据**，**断开连接**



> **建立连接：**通过**三次握手**，建立客户端和服务器端的连接，TCP提供**面向连接**的通信传输（通信开始之前做准备工作）  **三次握手**：发送三个数据包确认连接（确认客户端的接受能力和服务器端的发送能力）
>
> 第一次握手：由浏览器发起，告知服务器要发送请求 **SYN**
>
> 第二次握手：由服务器发起，告知浏览器已经准备接受请求  **SYN   ACK**
>
> 第三次握手：由浏览器发送，告诉服务器，即将发送请求   **SYN  ACK**



> **传输阶段**：**接收端要对每个数据包进行确认** 在规定时间内发送端没有接收到接收端发送的反馈消息则视为丢包，并触发重传机制，数据包到达接收端后，根据TCP头中的序列号为其排序，从而保证组成完整的数据



> **断开连接**： 数据传输完毕 **四次挥手**：
>
> 第一次挥手：浏览器发起，发送给服务器，请求报文发送完毕，你准备关闭
>
> 第二次挥手：服务器发起，发送给浏览器，报文接受完毕 我准备关闭 你也准备关闭
>
> 第三次挥手：服务器发起，告知浏览器，响应报文发送完毕 你准备关闭
>
> 第四次挥手：浏览器发起，告诉服务器，响应报文接受完毕，我准备关闭，你也准备
>
> 其实是客户端和服务端的两次挥手，也就是客户端和服务端分别释放连接的过程。可以看到，客户端在发送完最后一次确认之后，还要等待2MSL的时间。主要有两个原因，一个是为了**让B能够按照正常步骤进入CLOSED状态**，二是**为了防止已经失效的请求连接报文出现在下次连接中**。 





##### 5、DNS（域名系统）将域名和IP一一对应

##### 6、页面缓存

DNS缓存（将IP和域名关联起来）和页面缓存

[![DjEH81.png](https://s3.ax1x.com/2020/12/06/DjEH81.png)](https://imgchr.com/i/DjEH81)

浏览器通过HTTP响应头中的 **Cache-Control**字段来设置是否缓存该资源（可以通过Max-age设置缓存过期时长）

缓存未过期的情况下，再次请求该资源则直接返回缓存中的资源给浏览器

如果缓存过期了，浏览器继续发起HTTP请求，并且在HTTP请求头上带上

```js
If-None-Match:"4f80f-13c-3a1xb12a"
```

​	服务器收到请求头后根据这个值来判断资源是否更新，如果没有更新返回304状态码（协商缓存，服务器不重复发送资源给客户端，客户端使用缓存中的数据），如果资源更新了，就发送最新的资源给客户端



##### 7、登录状态怎样保存的

[![DjEXDO.png](https://s3.ax1x.com/2020/12/06/DjEXDO.png)](https://imgchr.com/i/DjEXDO)



> 用户首次登录时，输入账号密码，然后通过POST请求发送至服务器端，服务器端会判断用户登录信息是否正确，如果正确就会生成如下字段，并且将其写在响应头中，发送给客户端
>
> ```js
>  Set-Cookie: UID=3431uad; 
> ```
>
> 浏览器接收到响应头后，将**Set-Cookie**保存在本地，用户再次发送HTTP请求时，浏览器会先读取**Cookie**数据，并且会将携带 **Cookie字段**的请求头发送给服务器，服务器根据请求头判断用户是否已经登录，如果是则把包含该用户信息的页面数据返回给浏览器



##### 8、HTTP请求示意图

[![DjVHoQ.png](https://s3.ax1x.com/2020/12/06/DjVHoQ.png)](https://imgchr.com/i/DjVHoQ)





#### 9、从URL输入到页面显示，这中间发生了什么？



[![DjniFg.png](https://s3.ax1x.com/2020/12/06/DjniFg.png)](https://imgchr.com/i/DjniFg)





##### 1、用户输入

>  当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是**搜索内容**还是**请求的URL**

+ 如果是搜索内容，地址栏会使用默认搜索引擎，来合成带搜索内容的**URL地址**
+ 如果输入的是URL，地址栏会将这段内容加上协议，合成完整的**URL**



> 当用户输入关键字并且回车之后，页面将会被替换成新的页面，在此之前浏览器还可以执行一次 **`beforeunload`**事件的机会，**`beforeunload`**可以在页面切换之前进行一些数据清除的操作，同时用户也可以通过**`beforeunload`**取消导航，如果当前页面没有监听**`beforeunload`**这个事件或者同意了之后的流程，那么标签页就开始加载了



##### 2、URL请求过程

> 接下来进入页面资源请求过程，**浏览器进程**会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后开始发起真正的URL请求流程。



> 首先，网络进程会先查找本地缓存是否缓存了该资源，如果有，则直接返回该资源给浏览器进程，如果没有在缓存中查找到对应的资源，那么直接进入网络资源请求流程，先进行**DNS**解析，获取到服务器的IP地址，如果请求是HTTPS还需要建立**TLS**连接



> 接下来利用IP地址和服务器建立TCP连接，建立之后，浏览器会构建请求行，请求头等信息。并把和该域名相关的**Cookie**信息添加到请求头中，向服务器发起构建的请求



> 服务器接收到请求信息后，会根据请求信息生成响应数据（响应行，响应头，响应主体），并发给网络进程，网路进程接收到响应行和响应头后开始解析响应头里面的信息



###### （1）重定向

> 网络进程在解析响应头时，如果发现返回状态码是301，302（重定向到新页面），那么服务器需要浏览器**重定向**到其他的URL地址，网络进程会从**Location**里面读取到新的URL地址重新发起请求



> 如果返回状态码是200，那么浏览器就可以继续向下处理该请求了



###### （2）响应数据处理

> 浏览器会根据**Content-Type**中的信息判断，响应主体信息是什么样的类型
>
> + 如果是text/html，那么返回的数据就是HTML格式，**浏览器会继续进行导航流程**
> + 如果是 **application/octet-stream**显示是字节流类型的，浏览器就会按照**下载类型**来处理该请求，**请求会被提交给浏览器的下载管理器，同时URL请求的导航流程结束**



##### 3、准备渲染进程

> 默认情况下浏览器会为每个页面分配一个渲染进程，但如果多个页面处于**同一站点**（**相同协议，相同根域名**）（**从一个页面打开另一个新页面，而且两个页面属于同一站点，那么新页面就会复用父页面的渲染进程**）



> 渲染进程准备好以后，进入提交文档阶段





##### 4、提交文档

> 浏览器进程将网络进程接收到的HTML数据提交给渲染进程
>
> + 浏览器进程接收到网络进程的响应头数据后，就向渲染进程发起 **提交文档**的消息
> + 渲染进程接收到消息便和网络进程建立数据传输
> + 文档数据传输完成后，渲染进程返回确认提交的消息给浏览器进程
> + 浏览器进程接**收到确认提交的消息**后会更新浏览器的状态包括安全状态，地址栏的URL，前进后退的历史状态，并更新Web页面





##### 5、渲染阶段




