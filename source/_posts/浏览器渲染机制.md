---
title: 浏览器的底层渲染机制
date: 2020-11-19 16:45:57
tags: 浏览器渲染机制
categories: 浏览器
---
# **17、浏览器的底层渲染机制**



浏览器的地址栏中输入一个URl，到呈现页面经历了哪些事情

+ 向web服务器发送请求
+ 返回客户端对应界面的源码
+ DNS解析 HTTP/HTTPS/TCP/HTTP2.0
+ http报文
+ 网络层面优化：安全性和优化
+ 浏览器是多线程的JS（页面渲染）是单线程
+ 进程：程序中要进行的事情 一个进程中可能包含多个线程
+ 线程：程序中要进行的事情

#### 1、css加载

在页面加载过程中如果遇到__Link__：导入外部样式资源 浏览器会新开一个线程去服务器获取对应的资源 

（不会影响主线程的渲染）（可以理解为异步编程）（加载更快）

__内嵌样式__ 正常自上而下解析（解析完 再继续解析DOM结构）  （是一个优化的用途 不用发送请求 css样式很少或者移动端项目  以此减少HTTP资源请求 提高页面渲染的速度）

__@import__  此时不会开启新的线程去加载 而是让主线程去加载 阻止了DOM结构的继续渲染，只有等把外部样式导入进来，并且解析以后才会继续渲染DOM结构

（可以理解为同步编程）（除非必须加载这些样式再能继续往下 否则别用）





网络资源请求或者HTTP请求最大并发数 	大部分浏览器都维持在六个左右（为了避免资源要延迟加载，页面渲染																												速度变慢，我们应该尽可能减少HTTP请求数）





#### 2、JS加载

页面加载中遇到  **JS**（JS中会遇到操作DOM的代码）

script src= 'xxx'

##### 主线程会从服务器获取JS资源并进行加载 并把JS资源进行解析加载 加载完再渲染DOM结构

现在浏览器都具备了完善的代码扫描机制，如果script需要同步加载和渲染代码，浏览器在渲染js的时候会继续向下扫描代码，如果发现异步的代码资源，此时就开始加载请求了

如果设置了defer async 

##### 让其变为异步获取资源（不会阻碍DOM的渲染 ）

区别：defer可以遵循原有的顺序 获取以后按照顺序去以此渲染JS

​			async 是无序的 谁先回来谁先执行（如果js之间有依托关系 可能会报错）

​			因为在JS中还有可能操作CSS样式，所以哪怕都是异步请求资源的情况下，JS先加载会来，也要等待他之前			发送的CSS代码加载并渲染完成后才会执行代码



#### 思考：为什么CSS要写在上面 JS 要写在下面

link放在顶部是为了更快的加载CSS 

script 放在底部是为了获取DOM元素 或不阻碍DOM的渲染

​	 script放在**顶部**其实也**可以获取到要操作的DOM元素**    

​	 script  __defer/async__ src= xxx

​	 或者在那个script中 写window.DOMContentLoaded 

​		低版本不兼容使用onreadystatechange事件代替 监听document.readystateChange，值为complete代表		DOM结构加载完成







DOMContentLoaded 事件： 当DOM结构加载完成就会触发

​			DOM树生成 并且JS也执行 此时触发

Loaded：当所有资源都加载完才会触发

​			包含了需要等待的图片等资源都加载完才触发	



**回流** ：根据生成的渲染树，计算他们在设备视口（viewport）内的确切位置和具体大小

**重绘**： 根据渲染树和回流的到的几何信息，得到节点的绝对像素



 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129160020116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWppYW5mZW5nMTIxNA==,size_16,color_FFFFFF,t_70) 





**回流** ：元素的大小或者位置发生改变（页面布局和几何信息发生改变的时候），触发了重新布局，导致渲染树重			 新计算布局和渲染



**重绘**： 元素样式改变（宽高、大小、位置不变）

回流一定触发重绘，而重绘不一定会回流



优化之：避免DOM回流

+ 放弃传统DOM时代 使用react/vue（虚拟DOM   数据渲染）
+ 分离读写操作（集中在一次去操作DOM）
+ 集中样式改变（文件碎片化）
+ 动画效果应用到position属性为absolute或fixed元素上 （脱离文档）
+ CSS3硬件加速（GPU加速） transform opacity filters 这些属性会触发硬件加速，不会引发回流 但是会占用大量内存，性能消耗严重
+ 牺牲平滑度换取速度
+ 避免table 布局和使用CSS3的JavaScript表达式

